## 设计模式

> 说明：设计模式学习主要参考《图解设计模式》一书

### 适配器模式

类图：

![](E:\workspace\desigin-patterns\UML-pictures\适配器模式类图.jpg)

概述：让现有类去适应新的接口，从而可以在不修改原有代码情况下，构造出新的方法来适应新的需求。通俗的说就是对现有代码进行包装并复用。

详解：

1. 基于继承的适配

假设系统已经存在一个实现了从流中读取配置a功能的A类，但是随着要求的变化，a功能无法满足现有的需求，此时存在一个满足从文件读取配置需求的B接口，那么可以创建AAdapter来适配已有的A接口，然后继承B，通过b方法可以调用已经存在的a方法。

1. 基于复合/委托的适配		

委托方式达到的目的也是一样的，只不过此时的A不是接口而是类，并且B也是一个抽象类，不能同时extends多个类，所以只能通过在构造的时候将A传递作为成员变量，委托A的a功能

角色说明：

- A：属于Adaptee，被适配的对象，持有既定的方法。
- B：属于Target，即所需要的对象，满足所需的对象。
- AAdapter：适配器，满足所需的实现类

总结：

1. Adaptee和Target如果完全不同，是不能使用Adapter模式的
2. 主要用于填补不同接口的功能缝隙，Decorator模式是不改变接口下增强功能

### 工厂方法模式

类图

// TODO

概述：工厂方法模式中，父类决定实例的生成方式，但是不决定具体的实现，具体的实现交给子类实现。

详解：

​	工厂负责定义产品产生的流程，具体的工厂构建具体的产品，这样将生成实例的框架和具体实现生成实例的类分离，达到解耦目的。

角色说明：

- 工厂：属于Creator，抽象的工厂类，用于制定生成产品的方式
- 产品：属于Product，抽象的产品，用于定义具体产品持有的接口
- 具体工厂：ConcreteCreator，具体的工厂类，实现生成产品的方式
- 具体的产品：ConcreteProduct，具体的产品。

总结：

1. 工厂方法模式也可以将抽象类替换成具体类，通常在方法体抛出异常或者添加具体的默认实现，抛出异常控制只能在子类中实现。
2. 一般工厂方法和模板方法模式配合使用，createProduct就是一个模板方法



### 单例模式





最后总结：

实际上，每种设计模式并不是独立存在程序中，各个设计模式都是相互协调工作应用于系统中，在阅读框架代码时很难从一个点了解框架的设计，需要整体把控，才能在修改框架的时候不会损坏原有的架构。



